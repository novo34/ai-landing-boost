Perfecto, sigamos üòÑ

Primero despejo tu duda de n8n y luego arrancamos con el **plan de desarrollo** ya asumiendo que n8n ser√° el ‚Äúmotor interno‚Äù.

---

## 1Ô∏è‚É£ Tema legal de n8n y tu SaaS

> **‚ÄúProhibici√≥n Expresa de Multi-tenancy ‚Äî El Proveedor NO podr√° operar una instancia compartida de n8n para m√∫ltiples clientes, ni ofrecer n8n como servicio SaaS multi-inquilino.‚Äù**

üëâ Esto significa:

* **Lo que NO puedes hacer:**

  * No puedes montar ‚Äún8n Cloud versi√≥n Klever‚Äù donde tus clientes entren a **usar n8n directamente** (crear sus propios workflows, credenciales, etc.) como si fuera tu producto.
  * No puedes comercializar ‚Äúacceso a n8n‚Äù como servicio.

* **Lo que S√ç puedes hacer sin problema:**

  * Usar **n8n internamente**, como *motor orquestador* de tu producto SaaS.
  * Tus clientes **nunca ven n8n**, nunca tienen un usuario en n8n:
    ellos solo ven TU plataforma (Next/Nest), y t√∫ desde dentro llamas a n8n para ejecutar flujos.
  * Cada tenant (cliente) tiene su **configuraci√≥n, credenciales e ID** en TU base de datos.
    Tu backend traduce eso a llamadas a n8n (webhooks, HTTP Request, etc.).

üí° En resumen:
Tu SaaS vende **‚ÄúAgentes de WhatsApp + Automatizaciones‚Äù**, NO ‚Äún8n como producto‚Äù.
Mientras n8n sea **solo un componente interno de tu arquitectura**, no est√°s violando la cl√°usula de multi-tenancy.

Obviamente no es asesor√≠a legal formal, pero con ese uso est√°s en el patr√≥n habitual de ‚Äúmotor interno‚Äù.

---

## 2Ô∏è‚É£ Decisiones base del proyecto (dejamos esto YA fijado)

Tomando todo lo que dijiste, te propongo fijar esto como base:

* **Backend:** Node.js + **NestJS**

  * ORM: **Prisma** con MySQL (m√°s moderno y c√≥modo que TypeORM para multi-tenant + migraciones).
* **Frontend:** **Next.js** (App Router) + React

  * Razones:

    * Mejor para **SaaS B2B**: SEO, rutas protegidas, SSR/SSG, internacionalizaci√≥n, etc.
    * M√°s ordenado para auth, dashboards, √°rea p√∫blica de marketing, docs, etc.
  * Mobile-first con **TailwindCSS** + componente UI (Shadcn UI o similar).
* **Base de datos:** **MySQL** (multi-tenant)

  * Estrategia principal: **Single-DB, multi-tenant por `tenant_id`**, con:

    * `tenant_id` en todas las tablas de datos sensibles.
    * Filtros autom√°ticos a nivel de repositorios/servicios en Nest.
  * **Separaci√≥n jur√≠dica UE / Suiza:**

    * Opci√≥n 1 (m√≠nima viable):

      * Un cl√∫ster **principal en la UE (ej: Alemania)**.
      * Reglamentas en tu pol√≠tica que los datos de CH pueden alojarse en la UE (cumpliendo FADP y acuerdos).
    * Opci√≥n 2 (m√°s estricta, futura pero ya prevista en dise√±o):

      * Capas de abstracci√≥n para poder tener **dos cl√∫steres**: `eu-db` y `ch-db`,
        seleccionados seg√∫n `region` del tenant.
* **Almacenamiento de archivos (conversaciones exportadas, adjuntos, etc.):**

  * NO en la base de datos; en **object storage**:

    * Ej: S3 compatible (Wasabi, Backblaze, Bunny, etc.) o el storage que te ofrezca Hostinger.
    * Metadatos en MySQL, archivos (JSON, PDF, etc.) en buckets.
* **SSO:** preparado desde el inicio:

  * **Google** (OAuth2 / OpenID Connect)
  * **Microsoft** (Entra ID / Azure AD)
* **Pagos (Espa√±a + Suiza):**

  * **Stripe** como columna vertebral (acepta EUR y CHF, tarjetas, SEPA, etc.).
  * M√°s adelante puedes a√±adir proveedores locales si hace falta (pero lo dejamos previsto).
* **WhatsApp provider:**

  * Soportar:

    * **Evolution API** (tu proxy actual).
    * Conector futuro con proveedor oficial de WhatsApp Cloud API (Ej: Gupshup, 360dialog, Meta Direct).
* **n8n:** motor interno de automatizaci√≥n

  * Expuesto v√≠a Webhooks / REST desde Nest.
  * Cada agente/tenant se mapea a un **Workflow ID** + variables de contexto.

Con esto claro, ahora s√≠ vamos a lo que me pediste: **roadmap completo de inicio a fin**, sin dejar cosas ‚Äúpara despu√©s‚Äù.

---

## 3Ô∏è‚É£ Roadmap completo ‚Äì de 0 a SaaS profesional

Te lo estructuro en grandes BLOQUES, y dentro de cada uno habr√° PRDs/Specs individuales que luego pediremos a Cursor.

### Bloque A ‚Äî Fundamentos del SaaS (multi-tenant, auth, pagos, tenant panel)

**A1. Arquitectura base & repositorio monorepo**

* Monorepo (Turborepo o Nx) con:

  * `apps/backend` ‚Üí NestJS
  * `apps/web` ‚Üí Next.js
  * `packages/shared` ‚Üí tipos, modelos, utils comunes (DTOs, enums, etc.).
* Configuraci√≥n de entorno:

  * `.env`, `.env.production`, `.env.local` para:

    * DB (MySQL),
    * Stripe keys,
    * OAuth Google/Microsoft,
    * Evolution API base URL,
    * n8n base URL y credenciales de API.
* Pipeline de despliegue (aunque sea manual al inicio) hacia VPS Hostinger.

üëâ **PRD futuro:** ‚ÄúArquitectura monorepo + Setup inicial (Nest + Next + Prisma)‚Äù.

---

**A2. Modelo multi-tenant + migraciones**

* Dise√±o de entidades base:

  * `tenants`
  * `users`
  * `tenant_members` (rol: OWNER, ADMIN, AGENT, etc.)
  * `tenant_settings` (idioma por defecto, zona horaria, pa√≠s, moneda, etc.).
* Estrategia multi-tenant:

  * Todas las tablas de datos de negocio tienen `tenant_id`.
  * Capa en Nest:

    * ‚ÄúTenantContext‚Äù que se inyecta en cada request (extra√≠do de dominio, subdominio o JWT).
* Migraciones:

  * Est√°ndar Prisma:

    * `/prisma/schema.prisma`
    * `npx prisma migrate dev` (local)
    * `npx prisma migrate deploy` (prod)
  * Script inicial para seed:

    * Crear tenant de prueba,
    * Usuario owner,
    * Plan gratuito.

üëâ **PRD futuro:** ‚ÄúModelo multi-tenant y estrategia de migraciones con Prisma‚Äù.

---

**A3. Autenticaci√≥n + SSO + gesti√≥n de usuarios**

* Registro y login:

  * Email + contrase√±a (con verificaci√≥n por email).
  * Invitaci√≥n a equipo por email.
* SSO:

  * Botones ‚ÄúContinuar con Google‚Äù y ‚ÄúContinuar con Microsoft‚Äù.
  * Asociaci√≥n de identidad SSO a un `user` interno.
* Gesti√≥n de sesi√≥n:

  * Tokens JWT o cookies firmadas (recomendado con Next).
  * Middleware para proteger rutas y paneles.
* Roles:

  * `OWNER`, `ADMIN`, `USER` (operador), `VIEW_ONLY`.

üëâ **PRD futuro:** ‚ÄúAuth & SSO multi-tenant (email/password + Google + Microsoft)‚Äù.

---

**A4. Billing & suscripciones (Stripe)**

* Planes:

  * Free trial (X d√≠as configurable por tenant plan).
  * Plan b√°sico, plan pro, plan enterprise (editable por ti en c√≥digo al inicio).
* L√≥gica:

  * `subscriptions` table vinculada a `tenant_id`.
  * Webhooks Stripe para:

    * Activar / suspender / cancelar suscripci√≥n.
  * Estados:

    * `active`, `trialing`, `past_due`, `canceled`, `blocked`.
* Restricciones:

  * Si `trial` expirado y sin m√©todo de pago ‚Üí limitar agentes activos.
  * Si `past_due` cierto tiempo ‚Üí bloquear env√≠os autom√°ticos de mensajes del bot.

üëâ **PRD futuro:** ‚ÄúFacturaci√≥n y control de acceso por suscripci√≥n (Espa√±a + Suiza)‚Äù.

---

**A5. Panel de administraci√≥n del tenant (panel profesional)**

* Mobile-first, UI pro (no cutre):

  * Dashboard con:

    * Estado de suscripci√≥n,
    * Pr√≥xima factura,
    * Uso del sistema (mensajes, agentes, conversaciones).
* Apartados:

  * Equipo (invitaciones, roles).
  * Plan y facturaci√≥n (upgrade, downgrade, m√©todo de pago).
  * Ajustes generales del tenant (idioma, zona horaria, pa√≠s, moneda, logo, colores).

üëâ **PRD futuro:** ‚ÄúTenant Panel profesional (UI + UX + l√≥gica)‚Äù.

---

### Bloque B ‚Äî M√≥dulo WhatsApp & Evoluci√≥n API

**B1. Gesti√≥n de proveedores de WhatsApp**

* Entidades:

  * `whatsapp_providers` (Evolution, Official, etc.)
  * `tenant_whatsapp_accounts`

    * Proveedor
    * N√∫mero de tel√©fono
    * Status (connected, pending, revoked)
    * Tokens / claves cifradas.
* Flujos:

  * Owner configura y valida tu n√∫mero:

    * ‚ÄúConectar WhatsApp‚Äù ‚Üí wizard:

      1. Elegir proveedor (Evolution / Oficial).
      2. Introducir claves / QR flow.
      3. Guardar en DB.
  * Validaciones:

    * 1 n√∫mero pertenece a 1 tenant.
    * Posibilidad futura de m√∫ltiples n√∫meros por tenant (pero lo dejamos previsto en el modelo).

üëâ **PRD futuro:** ‚ÄúGesti√≥n de cuentas de WhatsApp por tenant‚Äù.

---

**B2. Webhooks de mensajes entrantes & salientes**

* Endpoint en Nest:

  * `/webhooks/whatsapp/:providerId`
* Funciones:

  * Recibir mensajes entrantes y:

    * Resolver `tenant` y `agent` al que pertenece.
    * Guardar en `conversations` y `messages`.
    * Enviar esos datos al motor de IA y/o a n8n.
  * Enviar mensajes salientes:

    * Desde Nest hacia Evolution/Cloud API.
    * Registrar estado de entrega (sent, delivered, seen, failed).

üëâ **PRD futuro:** ‚ÄúWebhooks WhatsApp + almacenamiento de conversaciones‚Äù.

---

### Bloque C ‚Äî Base de conocimiento (IA-first, multi-idioma, configurable por cliente)

Esta es la parte clave para que el agente sea bueno.

**C1. Modelo de base de conocimiento**

* Entidades:

  * `knowledge_sources`:

    * tipo: `FAQ`, `DOC`, `URL_SCRAPE`, `MANUAL_ENTRY`, `CALENDAR`, `CRM`, etc.
    * idioma.
  * `knowledge_chunks`:

    * Texto normalizado / vectorizado por chunk.
    * Referencias a origen.
  * `knowledge_collections`:

    * Para agrupar contenido: ‚ÄúServicios & Precios‚Äù, ‚ÄúPol√≠tica de cancelaciones‚Äù, etc.

* Arquitectura:

  * Almacenamiento texto: MySQL (contenido original + chunk).
  * Embeddings:

    * Opciones:

      * Guardar vectores en MySQL (campo JSON/LongText) o
      * Usar un vector store externo (ej: pgvector, Chroma, Qdrant).
    * Te propongo: **para v1**, vector store interno simple (tabla `embeddings`) con √≠ndices.

üëâ **PRD futuro:** ‚ÄúModelo de base de conocimiento multi-tenant, multi-idioma, con embeddings‚Äù.

---

**C2. Interfaces para que el cliente alimente su conocimiento**

* Web App:

  * Secci√≥n ‚ÄúBase de conocimiento‚Äù:

    * CRUD de FAQs:

      * Pregunta / Respuesta.
      * Idioma.
      * Categor√≠a.
    * Importar desde:

      * Documentos (PDF, DOCX ‚Üí extracci√≥n de texto).
      * Sitio web (URL + scraping b√°sico).
  * Configuraci√≥n:

    * Idioma principal del negocio.
    * Idiomas adicionales que soportar√° el bot.
* Roles:

  * Owner puede editar todo.
  * Cliente final (si le delegas acceso) puede editar s√≥lo algunas colecciones.
  * El owner (t√∫) puede ofrecer servicio de ‚ÄúSet up done-for-you‚Äù.

üëâ **PRD futuro:** ‚ÄúUI + API para crear/gestionar la base de conocimiento del tenant‚Äù.

---

**C3. Pipeline de ingesti√≥n y actualizaci√≥n**

* Cada vez que se a√±ade/edita contenido:

  * Normalizar texto.
  * Trocear en chunks (tama√±o √≥ptimo para embeddings).
  * Generar embedding con OpenAI (u otro modelo).
  * Guardar embedding vinculado al chunk.
* Estrategia idiomas:

  * Guardar idioma detectado.
  * Permitir consultas cross-language (ej: usuario escribe en alem√°n y contenido est√° en espa√±ol ‚Üí translation layer).

üëâ **PRD futuro:** ‚ÄúPipeline de ingesti√≥n + embeddings + detecci√≥n de idioma‚Äù.

---

### Bloque D ‚Äî Motor del Agente de Citas (WhatsApp Agent)

**D1. Dise√±o del ‚ÄúAgente‚Äù como entidad configurable**

* Entidad `agents`:

  * `tenant_id`
  * `name` (Ej: ‚ÄúRecepcionista WhatsApp‚Äù)
  * `language_strategy`: `auto_detect`, `fixed`, `multi_language`.
  * `knowledge_collections` asociados.
  * `calendar_connectors` usados.
  * `personality_settings`:

    * Tono (formal, cercano, etc).
    * Nombre del agente.
  * `n8n_workflow_id` (si se usa flujo externo).
  * `status`: active / paused / disabled.
* UI para que el tenant configure:

  * Idioma por defecto.
  * Tono de voz.
  * Qu√© colecciones de conocimiento usar√°.
  * Qu√© calendario se usa y reglas de cita (duraci√≥n, huecos, buffers, cancelaciones).

üëâ **PRD futuro:** ‚ÄúModelo y configuraci√≥n de Agentes por tenant‚Äù.

---

**D2. Orquestaci√≥n de conversaci√≥n (memoria + IA)**

* Memoria:

  * `conversations` y `messages` tablas:

    * Guardar todo el historial (cumpliendo GDPR/FADP, con opci√≥n de eliminaci√≥n/an√≥nimo).
  * Mechanismo de ‚Äúcontexto‚Äù:

    * √öltimos X mensajes relevantes.
    * Resumen de conversaci√≥n para contextos largos.
* Algoritmo del turn:

  1. Llega mensaje ‚Üí determinar idioma (detecci√≥n autom√°tica).
  2. Buscar conversaci√≥n existente con ese n√∫mero y ese agente.
  3. Construir contexto:

     * Mensajes recientes,
     * Resumen (si existe),
     * Info de usuario (nombre si ya se conoce),
     * Intent actual (si ya se detect√≥: ‚Äúagendar cita, cancelar, info precios‚Ä¶‚Äù).
  4. Llamar al **orquestador IA**:

     * LLM principal (OpenAI).
     * Consultas a base de conocimiento (RAG).
     * Llamadas a n8n o a servicios internos (calendar, CRM).
  5. Devolver respuesta ‚Üí enviar v√≠a WhatsApp.

üëâ **PRD futuro:** ‚ÄúOrquestador del agente de citas con memoria y RAG‚Äù.

---

**D3. Integraci√≥n con calendarios (Cal.com, Google Calendar, CRM propio)**

* Soportar en v1:

  * **Cal.com**:

    * Conexi√≥n por API Key + Event Types.
  * **Google Calendar**:

    * OAuth por usuario / service account seg√∫n dise√±o.
* Estructura:

  * `calendar_integrations` (per tenant).
  * `agent_calendar_rules`:

    * Duraci√≥n cita,
    * Horarios de atenci√≥n,
    * D√≠as disponibles,
    * Buffers,
    * Pol√≠tica de cancelaci√≥n.
* Flujo:

  * Agente propone rango de horas.
  * Cliente elige slot.
  * Se crea el evento en el calendar correspondiente.
  * Se envia confirmaci√≥n por WhatsApp.

üëâ **PRD futuro:** ‚ÄúM√≥dulo de integraci√≥n de calendarios multi-proveedor‚Äù.

---

### Bloque E ‚Äî Integraci√≥n con n8n como motor interno

**E1. Patr√≥n de integraci√≥n con n8n**

* Modelo:

  * `integrations_n8n_flows`:

    * `tenant_id`
    * `agent_id`
    * `workflow_id`
    * Tipo: `lead_intake`, `booking_flow`, `followup`, etc.
* Estrategia:

  * Para ciertos eventos:

    * `on_new_lead`
    * `on_booking_confirmed`
    * `on_payment_failed`, etc.
  * Nest env√≠a un payload a n8n:

    * v√≠a Webhook HTTP.
  * n8n hace:

    * Env√≠o de email,
    * Notificaci√≥n a due√±o,
    * Inserci√≥n en CRM,
    * Etc.

üëâ **PRD futuro:** ‚ÄúPatr√≥n de orquestaci√≥n n8n interno (sin exposici√≥n al cliente)‚Äù.

---

**E2. Preparar la plataforma para ‚Äúsincronizar flujos‚Äù**

* Punto importante:
  Cuando lleguemos aqu√≠, me pedir√°s:

  > ‚ÄúP√≠deme los JSON de los agentes que vamos a integrar en el sistema‚Äù
  > y conectaremos cada uno.
* En el dise√±o:

  * Guardar `workflow_id` y `target_event` en la config del Agente.
  * UI en el panel:

    * Checkboxes tipo:

      * ‚ÄúActivar flujo de bienvenida (n8n)‚Äù
      * ‚ÄúActivar flujo de recordatorio de citas (n8n)‚Äù

üëâ **PRD futuro:** ‚ÄúUI + modelo para activar/desactivar flujos n8n por agente/tenant‚Äù.

---

### Bloque F ‚Äî Multi-idioma, detecci√≥n de idioma, cumplimiento legal y automatizaciones

**F1. Multi-idioma completo (plataforma + agente)**

* Plataforma:

  * Internacionalizaci√≥n en Next:

    * Textos en `es-ES`, `de-CH`, `en`, `fr`, etc.
  * Selector de idioma en la UI.
* Agente:

  * Detecci√≥n autom√°tica del idioma del usuario (LLM o lib).
  * Respuesta en:

    * Idioma detectado, o
    * Idioma por defecto del negocio (seg√∫n configuraci√≥n).
  * Soporte de varios idiomas en la base de conocimiento.

üëâ **PRD futuro:** ‚ÄúSistema multi-idioma (UI + agente)‚Äù.

---

**F2. Cumplimiento GDPR + FADP (Suiza)**

* Features m√≠nimas:

  * Consentimiento expl√≠cito para uso de datos (texto configurable por tenant).
  * Opci√≥n de ‚Äúolvidar cliente‚Äù:

    * Borrado / anonimizaci√≥n de conversaciones por n√∫mero.
  * Retenci√≥n configurable por tenant (ej: borrar chats despu√©s de X meses).
  * P√°gina legal en la plataforma:

    * Aviso legal, privacidad, cookies.
* Segmentaci√≥n regi√≥n:

  * Campo `region` en tenant: `EU`, `CH`.
  * Pol√≠ticas por regi√≥n:

    * Textos legales adaptados (m√≠nimo).
  * (Legal profundo se ver√° con abogado, pero la arquitectura lo soporta).

üëâ **PRD futuro:** ‚ÄúM√≥dulo de cumplimiento de privacidad (GDPR + FADP)‚Äù.

---

**F3. Automatizaciones operativas (pruebas gratis, bloqueo por impago, etc.)**

* Estados autom√°ticos:

  * Trial:

    * Start trial al registrarse.
    * Planificaci√≥n de ‚Äútrial_end` y tareas:

      * Notificaciones (email, WhatsApp),
      * Limitaciones si no a√±ade m√©todo de pago.
  * Impago:

    * Webhook Stripe ‚Üí `past_due`.
    * Automatizaci√≥n:

      * Reducir capacidades del agente (por ej. solo responder mensajes simples).
      * Bloquear nuevas conversaciones si se prolonga la deuda.
* Todo configurable por owner en panel:

  * Duraci√≥n trial.
  * Grace period de impago.
  * Mensajes autom√°ticos predefinidos.

üëâ **PRD futuro:** ‚ÄúAutomatizaciones de ciclo de vida del cliente (trial, impago, bloqueo)‚Äù.

---

### Bloque G ‚Äî Extensiones futuras ya previstas: Voz, webchat, nuevos canales

Aunque se implementar√°n despu√©s, **la arquitectura** desde ya debe permitir:

* Soportar m√∫ltiples `channels`:

  * `whatsapp`, `webchat`, `voice`, `telegram`, etc.
* Tener tabla:

  * `channels` (por tenant),
  * `channel_agents` (mapeo agente ‚Üî canal).
* As√≠, cuando quieras agregar:

  * Voz (Twilio, Vonage, etc.).
  * Chat web embebible.
* Solo a√±adimos nuevos connectores reutilizando:

  * Mismo modelo de agente,
  * Misma base de conocimiento,
  * Misma orquestaci√≥n de IA.

üëâ **PRD futuro (cuando toque):** ‚ÄúSoporte multicanal: voz/webchat‚Äù.

---

## 4Ô∏è‚É£ ¬øQu√© hacemos AHORA mismo?

Tu √∫ltima frase fue: **‚ÄúSeguir usando N8N como motor interno, empecemos con el desarrollo‚Äù**.

El siguiente paso l√≥gico es:

### Paso 1: PRD + Spec para ‚ÄúFundamentos del SaaS‚Äù (Bloque A1 + A2)

Te propongo que empecemos por ah√≠ con Cursor.

En la pr√≥xima respuesta, si quieres, te doy **el primer prompt para Cursor** algo as√≠ como:

> ‚ÄúGenera el PRD y AI-Spec para el Bloque A1 + A2...‚Äù

Pero antes de eso, te dejo claro:

* El roadmap ya est√° **completo y de inicio a fin** (hasta extensiones de voz/canales).
* Incluye:

  * Node/NestJS, Next.js, MySQL
  * Multi-tenant completo
  * SSO Google/Microsoft
  * Billing para Espa√±a y Suiza
  * WhatsApp con EvolutionAPI
  * Base de conocimiento IA-first
  * n8n como motor interno
  * Multi-idioma y cumplimiento GDPR+FADP
  * Automatizaciones (trial, impago, bloqueo)
  * Preparado para futuros canales.

